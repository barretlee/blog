---
title: '揭秘 0.1 + 0.2 != 0.3'
description: 在采用 IEEE754 浮点数标准的语言中，0.1 + 0.2 都不会等于 0.3，但是 0.2 + 0.3 却等于 0.5，这是为何？想必这类问题也困扰着不少程序员。
warning: true
date: 2016-09-28 23:05:23
categories:
  - 前端杂烩
  - JavaScript
tags:
  - IEEE754
---


"0.1 + 0.2 = ?"，这道题如果给小学生，他会立马告诉你答案是 0.3，但是交给一些程序去计算，结果就不是那么简单了。

![math](/blogimgs/2016/09/28/6c0378f8gw1f89pd8hm96j20p00dwacm.jpg)<!--<source src="http://ww4.sinaimg.cn/large/6c0378f8gw1f89pd8hm96j20p00dwacm.jpg">-->

<!-- more -->

事实上，不仅仅是 JS，在其他采用 IEEE754 浮点数标准的语言中，0.1 + 0.2 都不会等于 0.3，但是 0.2 + 0.3 却等于 0.5，这是为何？想必这类问题也困扰着不少程序员。

### IEEE754 浮点数的演算

我们知道，科学计数法中 30000 可以写成 3x10<sup>4</sup>，以 10 为底数 4 为指数的科学计数法。在 IEEE754 标准中是比较类似的，只不过它是二进制数，底数也为 2。

IEEE 754 中最常用的浮点数值表示法是：单精确度（32位）和双精确度（64位），JavaScript 采用的是后者。举个例子，十进制数 150，使用双精度浮点数表示法，表示如下：

```javascript
// D 表示十进制，B 表示二进制
150D = 2^8 * 0.1001011B // 后面省略了 46 个 0
```

可以通过短除法计算：

```
   150   余数位
÷    2
---------------
    75     0   
÷    2
---------------
    37     1
÷    2
---------------
    18     1
÷    2
---------------
     9     0
÷    2
---------------
     4     1
÷    2
---------------
     2     0
÷    2
---------------
     1     0
÷    2
---------------
     0     1
```

最后一个余数为高位值，于是拿到 150 对应的二进制数位 `1001011`，也就等于 `2^8 * 0.1001011`。

上面是整数的表示法，而小数的表示法采用的是乘二取整，如 0.1，它的二进制表示为：

```javascript
// (0011) 表示循环
0.1D = 2^-3 * 0.110011(0011)
```

其演算方法如下：

```
    0.1   整数位
×     2
---------------
    0.2     0 
×     2
---------------
    0.4     0   * ↓
×     2
---------------
    0.8     0 
×     2
---------------
    1.6     1 
×     2
---------------
    1.2     1
×     2
---------------
    0.4     0   * ↑
             (0011循环)
```

与整数不同的是，第一个计算得到的整数位为最高位，故 0.1 对应的二进制数为 `0.000110011(0011)`，也就等于 `2^-3 0.1100110011(0011)`。

如果一个数既包含整数部分，又包含小数部分，其表示法的计算，需要分拆为整数和小数两部分，然后相加得到结果。

### IEEE754 浮点数精度丢失

IEEE754 浮点数表示法的数据格式如下图：

```javascript
// 下图采用大端表示，高位在左，低位在右。

sign  exponent         fraction
+---+----------+---------------------+
| 1 |   2~12   |         13~64       |
+---+----------+---------------------+
```

- 符号位：高位第 1 位，如图 sign 部分
- 指数位：高位第 2~12 位，如图 exponent 部分
- 尾数位：剩下的 fraction 部分

从上面小数的乘二取整演算中可以看到，有些小数对应的二进制数是无法写全的，比如 0.1，而 fraction 尾数部分有要求，只允许 52 位，超过部分进一舍零。

那么，我们就可以得到：

```
0.1D 
= 2^-4 * 1.10011(0011)B
= 2^-4 * 1.10011(0011 repeat 12 times)0011B // ← 最后一位为 1，进 1
= 2^-4 * 1.10011(0011 repeat 12 times)010B
```

### 揭秘 0.1 + 0.2

根据上面我们了解到的知识，我们可以很容易算出这些值：

```javascript
0.1D = 2^-4 * 1.1001100110011001100110011001100110011001100110011010B
0.2D = 2^-3 * 1.1001100110011001100110011001100110011001100110011010B
0.3D = 2^-2 * 1.0011001100110011001100110011001100110011001100110011B
```

`0.1 + 0.2` 时，先将两者指数统一为 -3，故 0.1 小数点向左移一位，于是：

```
   0.1100110011001100110011001100110011001100110011001101B
+  1.1001100110011001100110011001100110011001100110011010B
------------------------------------------------------------
= 10.0110011001100110011001100110011001100110011001100111B
```

得到的二进制数为：

```
10.0110011001100110011001100110011001100110011001100111B
```

小数点往左移一位使得整数部分为 1，此时尾数部分为 53 位，进一舍零，于是得到最后的值是：

```
2^-2 * 1.0011001100110011001100110011001100110011001100110100
```

这个值转化成真值，结果为：`0.30000000000000004`。那么 `0.1 + 0.2 = 0.30000000000000004` 的推演到这里就结束了。


### 相关验证

毕竟咱们手动计算可能存在笔误，可以通过一个叫做 `double-bits` 的 npm 进行推演，我写了一个小 demo，感兴趣的可以玩耍下：

```javascript
const db = require('double-bits');
const pad = require('pad');

// [lo, hi] where lo is a 32 bit integer and hi is a 20 bit integer.
const base2Str = (n) => {
  const f = db.fraction(n);
  const s = db.sign(n) ? '-' : '';
  const e = `2^${db.exponent(n) + 1}`;
  const t = `0.${pad(f[1].toString(2), 20, '0')}${pad(f[0].toString(2), 32, '0')}`;
  return `${s}${e} * ${t}`;
};

console.log(base2Str(0.1).toString(2));
console.log(base2Str(0.2).toString(2));
console.log(base2Str(0.3).toString(2));
console.log(base2Str(1.2).toString(2));
```

上面输出结果为：

```javascript
2^-3 * 0.11001100110011001100110011001100110011001100110011010
2^-2 * 0.11001100110011001100110011001100110011001100110011010
2^-1 * 0.10011001100110011001111001100110011001100110011001100
2^1 * 0.10011001100110011001111001100110011001100110011001100
```

### 最后

为了按照计算机的思维，IEEE754 的标准来计算 `0.1 + 0.2`，又重新复习了一遍大学计算机基础的知识，原码、反码、补码，以及除二取余、乘二取整计算法，最后能够推演出来，也算是一个胜利吧~

### 更多阅读

- [IEEE 754 Converter](http://www.h-schmidt.net/FloatConverter/IEEE754.html)
- [维基百科 IEEE 754](https://zh.wikipedia.org/wiki/IEEE_754)

---

题图：[math](https://unsplash.com/search/math?photo=5mZ_M06Fc9g) by Roman Mager

***笔耕不辍，欢迎关注微信公众号小胡子哥（barretlee_com），分享生活，分享技术，我在那里等你。***

